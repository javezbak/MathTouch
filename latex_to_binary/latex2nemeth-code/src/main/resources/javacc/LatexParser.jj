/* LatexParser.jj 
	A (not so) simple latex parser for  Braille/Nemeth generation.
	Author Andreas Papasalouros, Aggelos Giantsos 2014-2017.
*/

options {	
	STATIC = false;
	UNICODE_INPUT = true; // UNICODE input!
}
PARSER_BEGIN(Latex)

package com.latex2nemeth.parser;
import java.io.*;
import java.util.regex.*;
import java.util.Vector;
import java.util.HashMap;
import java.util.Map;

import com.latex2nemeth.ast.*;
import com.latex2nemeth.utils.*;
import com.latex2nemeth.symbols.*;
import com.latex2nemeth.parser.aux.*;
import com.latex2nemeth.io.*;

public class Latex {

  	static final int MAX_WIDTH = 28;
	static int COLUMN = 0;
	static StringBuffer WORD = new StringBuffer(); 
	NemethTable table;
	HashMap<String,String > commandTable = new HashMap<String,String >();
	static HashMap<String, Theorem> theorems = new HashMap<String,Theorem >();
	static Writer output;
	static String outputFileName;
	int enumeratedepth = 0;
	private static LabelTable labeltable;
	int lineNumber=0;
	static ParsedChapters parsedChapters;
	
	static int chapter = 0;
	static int section = 0;
	static int subsection = 0;
	private int picture = 0;
	private Preamble preamble;

    private String getLetterCode(String symbol) {
        String code = table.getLetterCode(symbol);
        if (code == null) {
            System.out.println("UNKNOWN TEXT SYMBOL: " + symbol + " at line: " + jj_input_stream.getEndLine());
            return "";
        }
        return code;
    }

    private String getTheoremCode(String symbol) {
        String code = table.getTheoremCode(symbol);
        if (code == null) {
            System.out.println("UNKNOWN THEOREM SYMBOL: " + symbol + " at line: " + jj_input_stream.getEndLine());
            return "";
        }
        return code;
    }
	
    private String getMathCode(String symbol) {
        String code = table.getMathCode(symbol);
        if (code == null) {
            System.out.println("UNKNOWN MATH SYMBOL: " + symbol + " at line: " + jj_input_stream.getEndLine());
            return "";
        }
        return code;
    }

    String string2Braille(String str) {
        StringBuffer buffer = new StringBuffer();

        for (int pos = 0; pos < str.length(); pos++) {
            String c = Character.toString(str.charAt(pos));
            buffer.append(getLetterCode(c));
        }

        return buffer.toString();
    }

    String string2BrailleTheorem(String str) {
        StringBuffer buffer = new StringBuffer();

        for (int pos = 0; pos < str.length(); pos++) {
            String c = Character.toString(str.charAt(pos));
            buffer.append(getTheoremCode(c));
        }

        return buffer.toString();
    }

    static String italic(String s) {
        return "\u2820\u2804\u2838" + s + "\u2838\u2820\u2804";
    }

    String bold(String s) {
        return getLetterCode("\\textbf-open") + s + getLetterCode("\\textbf-close");
    }

    static String sansserif(String s) {
        return s;
    }

    static String scriptenglish(String s) {
        return s;
    }

    static boolean checkforPreviousSpace(Token t) {
        boolean space = t.specialToken != null;
        return space;
    }

    public Latex(NemethTable table, InputStreamReader inputStreamReader, Preamble preamble) {
        this(inputStreamReader);
        this.table = table;
        this.preamble = preamble;
    }

    public static ParsedChapters parse(String texFile, String auxFile, NemethTable table, Preamble preamble) throws ParseException, TokenMgrError, IOException {

        parsedChapters = new ParsedChapters();

        FileInputStream fileInputStream = new FileInputStream(texFile);
        InputStreamReader inputStreamReader = new InputStreamReader(fileInputStream, "UTF-8");
        System.out.println("Parsing file: " + texFile);

        labeltable = new LabelTable();
        labeltable.createlabels(auxFile);

        output = new StringWriter();

        WORD = new StringBuffer();
        Latex parser = new Latex(table, inputStreamReader, preamble);

        parser.latex();

        inputStreamReader.close();
        fileInputStream.close();

        output.flush(); //??
        output.close();
        parsedChapters.put(chapter, output.toString());
        return parsedChapters;
    }
}
PARSER_END(Latex)

//SKIP : {" "}
SPECIAL_TOKEN : { " " | "\t" | "\n" | "\r" | "\r\n" }

//SKIP : { "\n" | "\r" | "\r\n" }
// Latex comments.
SKIP : {<"%" (~["\n"])* "\n">}

//TOKEN : {<WORD:  (~[" "])+ " " >}

TOKEN : {<TWONEWLINES : "\n\n" | "\r\n\r\n" | "\r\r">}

TOKEN : {<BEG : "\\begin" (" ")* "{"> : ENVSTATE}
<ENVSTATE> TOKEN : {<ENVNAME: (["A"-"Z","a"-"z"])+ >: ENVENDSTATE}
<ENVENDSTATE> TOKEN : {<ENVEND: "}"> : DEFAULT}

TOKEN : {<END : "\\end" (" ")* "{" > : ENVSTATE}

TOKEN : {<DIGIT0 : ["0"-"9"]> : NUM}
<NUM> TOKEN : {<DIGIT1 : ["0"-"9",","]> {} : NUM}
<NUM> SKIP : {<NODIGIT : ~["0"-"9",","]> {input_stream.backup(1);} : DEFAULT}

TOKEN : {<ENGLISHLETTER : ["A"-"Z","a"-"z"]>}
TOKEN : {<TEXTSYMBOL : "'" | "/" | ":" | ";" | "?" | "!" | "~" | "," |
                       "=" | "+" | "-" | "*" | ">" | "<" | "@" | "\\@" |
                       "--" | "---" | "\\ " | "\\," | "\\\n" | "\\quad" | 
		       "\\qquad" | "\\#">}

TOKEN : {<GREEKLETTER: ["Α"-"Ω" , "\u00b6", "α"-"ω", "«", "»", "ά", "έ", "ή", "ί", "ό", "ύ", "ώ",
                        "ϊ", "ϋ", "Ά", "Έ", "Ή", "Ί", "Ό", "Ύ", "Ώ"]>}

TOKEN : {<DIPHTHONG : "αι" | "αί" | "Αι" | "Αί" |
  	                  "αυ" | "αύ" | "Αυ" | "Αύ" |
                      "οι" | "οί" | "Οι" | "Οί" |
                      "ου" | "ού" | "Ου" | "Ού" |
                      "ει" | "εί" | "Ει" | "Εί" |
                      "ευ" | "εύ" | "Ευ" | "Εύ" |
                      "υι" | "υί" | "Υι" | "Υί" |
                      "ηυ" | "ηύ" | "Ηυ" | "Ηύ" |
"ΐ" |
"ΰ" |
"αὶ"|
"αί"|
"αἰ"|
"αἱ"|
"αἲ"|
"αἳ"|
"αἴ"|
"αἵ"|
"αἶ"|
"αἷ"|
"Αὶ"|
"Αί"|
"Αἰ"|
"Αἱ"|
"Αἲ"|
"Αἳ"|
"Αἴ"|
"Αἵ"|
"Αἶ"|
"Αἷ"|
"εὶ"|
"εί"|
"εἰ"|
"εἱ"|
"εἲ"|
"εἳ"|
"εἴ"|
"εἵ"|
"εἶ"|
"εἷ"|
"Εὶ"|
"Εί"|
"Εἰ"|
"Εἱ"|
"Εἲ"|
"Εἳ"|
"Εἴ"|
"Εἵ"|
"Εἶ"|
"Εἷ"|
"οὶ"|
"οί"|
"οἰ"|
"οἱ"|
"οἲ"|
"οἳ"|
"οἴ"|
"οἵ"|
"οἶ"|
"οἷ"|
"Οὶ"|
"Οί"|
"Οἰ"|
"Οἱ"|
"Οἲ"|

"Οἳ"|
"Οἴ"|
"Οἵ"|
"Οἶ"|
"Οἷ"|
"υὶ"|
"υί"|
"υἰ"|
"υἱ"|
"υἲ"|
"υἳ"|
"υἴ"|
"υἵ"|
"υἶ"|
"υἷ"|
"Υὶ"|
"Υί"|
"Υἰ"|
"Υἱ"|
"Υἲ"|
"Υἳ"|
"Υἴ"|
"Υἵ"|
"Υἶ"|
"Υἷ"|
"αὺ"|
"αύ"|
"αὐ"|
"αὑ"|
"αὒ"|
"αὓ"|
"αὔ"|
"αὕ"|
"αὖ"|
"αὗ"|
"Αὺ"|
"Αύ"|
"Αὐ"|
"Αὑ"|
"Αὒ"|
"Αὓ"|
"Αὔ"|
"Αὕ"|
"Αὖ"|
"Αὗ"|
"εὺ"|
"εύ"|
"εὐ"|
"εὑ"|
"εὒ"|
"εὓ"|
"εὔ"|
"εὕ"|
"εὖ"|
"εὗ"|
"Εὺ"|
"Εύ"|
"Εὐ"|
"Εὑ"|

"Εὒ"|
"Εὓ"|
"Εὔ"|
"Εὕ"|
"Εὖ"|
"Εὗ"|
"ηὺ"|
"ηύ"|
"ηὐ"|
"ηὑ"|
"ηὒ"|
"ηὓ"|
"ηὔ"|
"ηὕ"|
"ηὖ"|
"ηὗ"|
"Ηὺ"|
"Ηύ"|
"Ηὐ"|
"Ηὑ"|
"Ηὒ"|
"Ηὓ"|
"Ηὔ"|
"Ηὕ"|
"Ηὖ"|
"Ηὗ"|
"οὺ"|
"ού"|
"οὐ"|
"οὑ"|
"οὒ"|
"οὓ"|
"οὔ"|
"οὕ"|
"οὖ"|
"οὗ"|
"Οὺ"|
"Ού"|
"Οὐ"|
"Οὑ"|
"Οὒ"|
"Οὓ"|
"Οὔ"|
"Οὕ"|
"Οὖ"|
"Οὗ"|
"αι"|
"αί"|
"Αι"|
"Αί"|
"αυ"|
"αύ"|
"Αυ"|
"Αύ"|
"ει"|
"εί"|
"Ει"|
"Εί"|
"ευ"|

"εύ"|
"Ευ"|
"Εύ"|
"οι"|
"οί"|
"Οι"|
"Οί"|
"ου"|
"ού"|
"Ου"|
"Ού"|
"υι"|
"υί"|
"Υι"|
"Υί"|
"ηυ"|
"ηύ"|
"Ηυ"|
"Ηύ"|


"ὰ"|
"ά"|
"ἀ"|
"ἁ"|
"ἂ"|
"ἃ"|
"ἄ"|
"ἅ"|
"ἆ"|
"ἇ"|
"ᾶ"|

"ᾳ"|
"ᾲ"|
"ᾴ"|
"ᾀ"|
"ᾁ"|
"ᾂ"|
"ᾃ"|
"ᾄ"|
"ᾅ"|
"ᾆ"|
"ᾇ"|
"ᾷ"|

"ὲ"|
"έ"|
"ἐ"|
"ἑ"|
"ἒ"|
"ἓ"|
"ἔ"|
"ἕ"|


"ὴ"|
"ή"|
"ἠ"|
"ἡ"|
"ἢ"|
"ἣ"|
"ἤ"|
"ἥ"|
"ἦ"|
"ἧ"|
"ῆ"|

"ῃ"|
"ῂ"|
"ῄ"|
"ᾐ"|
"ᾑ"|
"ᾒ"|
"ᾓ"|
"ᾔ"|
"ᾕ"|
"ᾖ"|
"ᾗ"|
"ῇ"|

"ὶ"|
"ί"|
"ἰ"|
"ἱ"|
"ἲ"|
"ἳ"|
"ἴ"|
"ἵ"|
"ἶ"|
"ἷ"|
"ῖ"|

"ὸ"|
"ό"|
"ὀ"|
"ὁ"|
"ὂ"|
"ὃ"|
"ὄ"|
"ὅ"|

"ὺ"|
"ύ"|
"ὐ"|
"ὑ"|
"ὒ"|
"ὓ"|
"ὔ"|
"ὕ"|
"ὖ"|
"ὗ"|
"ῦ"|

"ὼ"|
"ώ"|
"ὠ"|
"ὡ"|
"ὢ"|
"ὣ"|
"ὤ"|
"ὥ"|
"ὦ"|
"ὧ"|
"ῶ"|

"ῳ"|
"ῲ"|
"ῴ"|
"ᾠ"|
"ᾡ"|
"ᾢ"|
"ᾣ"|
"ᾤ"|
"ᾥ"|
"ᾦ"|
"ᾧ"|
"ῷ"|

"ῤ"|
"ῥ"|
"Ῥ"|

"Ὰ"|
"Ά"|
"Ἀ"|
"Ἁ"|
"Ἂ"|
"Ἃ"|
"Ἄ"|
"Ἅ"|
"Ἆ"|
"Ἇ"|
" "|
"ᾼ"|
"ᾈ"|
"ᾉ"|
"ᾊ"|
"ᾋ"|
"ᾌ"|
"ᾍ"|
"ᾎ"|
"ᾏ"|


"Ὲ"|
"Έ"|
"Ἐ"|
"Ἑ"|
"Ἒ"|
"Ἓ"|
"Ἔ"|
"Ἕ"|

"Ὴ"|
"Ή"|
"Ἠ"|
"Ἡ"|
"Ἢ"|
"Ἣ"|
"Ἤ"|
"Ἥ"|
"Ἦ"|
"Ἧ"|

"ῌ"|
"ᾘ"|
"ᾙ"|
"ᾚ"|
"ᾛ"|
"ᾜ"|
"ᾝ"|
"ᾞ"|
"ᾟ"|


"Ὶ"|
"Ί"|
"Ἰ"|
"Ἱ"|
"Ἲ"|
"Ἳ"|
"Ἴ"|
"Ἵ"|
"Ἶ"|
"Ἷ"|
" "|
"Ὸ"|
"Ό"|
"Ὀ"|
"Ὁ"|
"Ὂ"|
"Ὃ"|
"Ὄ"|
"Ὅ"|

"Ὺ"|
"Ύ"|
"Ὑ"|
"Ὓ"|
"Ὕ"|
"Ὗ"|


"Ὼ"|
"Ώ"|
"Ὠ"|
"Ὡ"|
"Ὢ"|
"Ὣ"|
"Ὤ"|
"Ὥ"|
"Ὦ"|
"Ὧ"|
" "|

"ῼ"|
"ᾨ"|
"ᾩ"|
"ᾪ"|
"ᾫ"|
"ᾬ"|
"ᾭ"|
"ᾮ"|
"ᾯ"|


"᾽"|
"ι"|
"᾿"|
"῀"|
"῁"|
"῍"|
"῎"|
"῏"|
"῝"|
"῞"|
"῟"|
"ῒ"|
"ΐ"|
"ῗ"|
"ῢ"|
"ΰ"|
"ῧ"|
"῭"|
"΅"|
"`"|
"´"|
"῾"|

"ᾰ"|
"ᾱ"|
"Ᾰ"|
"Ᾱ"|
"ῐ"|
"ῑ"|
"Ῐ "|
"Ῑ "|
"ῠ"|
"ῡ"|
"Ῠ"|
"Ῡ"|

"αῖ"|
"Αῖ"|
"αῦ"|
"Αῦ"|
"εῖ"|
"Εῖ"|
"εῦ"|
"Εῦ"|
"οῖ"|
"Οῖ"|
"οῦ"|
"Οῦ"|
"υῖ"|
"Υῖ"|
"ηῦ"|
"Ηῦ" >}

TOKEN : {<ACCENT: "\\'">}
TOKEN : {<GRAVEACCENT: "\\`">}

TOKEN : {<INLINEMATH: "$">}

TOKEN : {<USEPACKAGE: "\\usepackage">}
TOKEN : {<DOCUMENTCLASS: "\\documentclass">}
TOKEN : {<NEWTHEOREM: "\\newtheorem">}

// Label and ref should be commands...
TOKEN : {<LABEL: "\\label">}
TOKEN : {<REF: "\\ref" | "\\eqref">}
TOKEN : {<INDEX: "\\index">}
TOKEN : {<TEXTBF: "\\textbf">}
TOKEN : {<TEXTIT: "\\textit" >}
TOKEN : {<TEXTCIRCLED: "\\textcircled" >}
TOKEN : {<INPUT: "\\Input" | "\\input" >}
TOKEN : {<INCLUDE: "\\include" >}
TOKEN : {<NEWCOMMAND: "\\newcommand" >}

TOKEN : {<HUGE: "\\huge" >}

TOKEN : {<MATHBEGIN : "\\[" | "\\begin" (" ")* "{math}"| "\\begin" (" ")* "{equation}"| "\\begin" (" ")* "{equation*}" >}
TOKEN : {<MATHEND : "\\]" | "\\end" (" ")* "{math}" | "\\end" (" ")* "{equation}"| "\\end" (" ")* "{equation*}">}
TOKEN : {<MATHBEND : "$$" >}

//BLIAH!
TOKEN : {<BEGINQUOTE: "\\begin" (" ")* "{quote}" >}
TOKEN : {<ENDQUOTE: "\\end" (" ")* "{quote}" >}
TOKEN : {<BEGINDOCUMENT: "\\begin" (" ")* "{document}" >}
TOKEN : {<ENDDOCUMENT: "\\end" (" ")* "{document}" >}
TOKEN : {<BEGINENUMERATE: "\\begin" (" ")* "{enumerate}" >}
TOKEN : {<ENDENUMERATE: "\\end" (" ")* "{enumerate}" >}
TOKEN : {<BEGINITEMIZE: "\\begin" (" ")* "{itemize}" >}
TOKEN : {<ENDITEMIZE: "\\end" (" ")* "{itemize}" >}
TOKEN : {<BEGINDESCRIPTION: "\\begin" (" ")* "{description}" >}
TOKEN : {<ENDDESCRIPTION: "\\end" (" ")* "{description}" >}
TOKEN : {<BEGINFIGURE: "\\begin" (" ")* "{figure}" >}
TOKEN : {<ENDFIGURE: "\\end" (" ")* "{figure}" >}
TOKEN : {<BEGINCENTER: "\\begin" (" ")* "{center}" >}
TOKEN : {<ENDCENTER: "\\end" (" ")* "{center}" >}
TOKEN : {<BEGINCASES: "\\begin" (" ")* "{cases}" >}
TOKEN : {<ENDCASES: "\\end" (" ")* "{cases}" >}
TOKEN : {<BEGINPMATRIX: "\\begin" (" ")* "{pmatrix}" >}
TOKEN : {<ENDPMATRIX: "\\end" (" ")* "{pmatrix}" >}
TOKEN : {<BEGINBMATRIX: "\\begin" (" ")* "{bmatrix}" >}
TOKEN : {<ENDBMATRIX: "\\end" (" ")* "{bmatrix}" >}

TOKEN : {<BEGINSPLIT: "\\begin" (" ")* "{split}" >}
TOKEN : {<ENDSPLIT: "\\end" (" ")* "{split}" >}
TOKEN : {<BEGINPROOF: "\\begin" (" ")* "{proof}" >}
TOKEN : {<ENDPROOF: "\\end" (" ")* "{proof}" >}

TOKEN : {<BEGINPSPICTURE: "\\begin" (" ")* "{pspicture}" >}
TOKEN : {<ENDPSPICTURE: "\\end" (" ")* "{pspicture}" >}

TOKEN : {<TEXTLATIN : "\\textlatin" >}
TOKEN : {<ITEM : "\\item" >}
TOKEN : {<CHAPTER: "\\chapter" >}
TOKEN : {<SECTION: "\\section" >}
TOKEN : {<SUBSECTION: "\\subsection" >}

TOKEN : {<FRAC : "\\frac">}
TOKEN : {<SQRT : "\\sqrt"|"\\leftroot"|"\\uproot">}
TOKEN : {<LEFT : "\\left" >}
TOKEN : {<RIGHT: "\\right" >}
TOKEN : {<TEXTRM: "\\textrm" |"\\mathrm"| "\\text">}
TOKEN : {<INTERTEXT: "\\intertext" >}
TOKEN : {<HBOX: "\\hbox" >}
TOKEN : {<TILDE: "\\tilde">}
TOKEN : {<WIDETILDE: "\\widetilde" >}

TOKEN : { < LTNALLCAPS: "\\latextonemethallcaps" | "\\ltnallcaps" > }

TOKEN : {<TEXTSC: "\\textsc" >}
TOKEN : {<OVERLINE: "\\overline" >}
TOKEN : {<UNDERLINE: "\\underline" >}
TOKEN : {<DOT: "\\dot" >}
TOKEN : {<LENQNO: "\\lenqno" >}
TOKEN : {<HAT: "\\hat" >}
TOKEN : {<VEC: "\\vec" >}
TOKEN : {<BAR: "\\bar" >}
TOKEN : {<STACKREL: "\\stackrel" >}
TOKEN : {<CHECK: "\\check" >}
TOKEN : {<ACUTE: "\\acute" >}
TOKEN : {<GRAVE: "\\grave" >}
TOKEN : {<CASES: "\\cases" >}
TOKEN : {<CR: "\\cr" >}
TOKEN : {<CAPTION: "\\caption" >}
TOKEN : {<BREVE: "\\breve" >}
TOKEN : {<DDOT: "\\ddot" >}
TOKEN : {<MATHRING: "\\mathring" >}


//TOKEN : {<IT: "\\it" >}
//TOKEN : {<RM: "\\rm" >} //ignored
//TOKEN : {<SL: "\\sl" >} //ignored
//TOKEN : {<BF: "\\bf" >}
//TOKEN : {<EM: "\\em" >}
//TOKEN : {<SC: "\\sc" >}


TOKEN : {<BINOM: "\\binom" >}
TOKEN : {<MATHBB: "\\mathbb"|"\\mathbf" | "\\mathfrak">}
TOKEN : {<MATHCAL: "\\mathcal" >}
TOKEN : {<UNDERBRACE: "\\underbrace" >}
TOKEN : {<OVERBRACE: "\\overbrace" >}

TOKEN : {<MATHSYMBOL: "\\ " | "\\quad"| "\\!"|"\\:"|"\\;">} 

TOKEN : {<MATHTEXTSEPARATOR: "("|")" | "." | "|" | "\\{"| "\\}"|"\\|">}
TOKEN : {<MATHSEPARATOR: "\\rangle" | "\\langle"| "\\llbracket" | "\\rrbracket">}
TOKEN : { <DELIMITERSIZEMODIFIER:  "\\bigr" | "\\bigl" |"\\biggr" | "\\biggl" |
                                   "\\Bigr" | "\\Bigl" |"\\Biggr" | "\\Biggl" | "\\big" | "\\bigg">}
  
TOKEN : {<SUP: "^">}
TOKEN : {<SUB: "_">}
TOKEN : {<LCB: "{">}
TOKEN : {<RCB: "}">}

TOKEN : {<LBRA: "[">}
TOKEN : {<RBRA: "]">}
TOKEN : {<AMPERSAND: "&">}

TOKEN : {<NEWLINE: "\\\\" | "\\newline"| "\\newpage">}

/* Standard functions, sin, cos, etc */
//TOKEN : {<BASICFUNCTION: "\\sin" | "\\cos">}
  
TOKEN : {<COMMAND : "\\" ("$" |(["A"-"Z","a"-"z","&","@"])+("*")?)>}

TOKEN: {<ANY: ~[] >}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// SYNTACTICAL //////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////

Token mathDelimiter():
{
    Token t;
}
{
    (t = <MATHTEXTSEPARATOR> | t = <MATHSEPARATOR> | t = <LBRA> | t = <RBRA>) { return t; }
}

// It sucks but it works...
Token mathDelimiter_no_brackets():
{
    Token t;
}
{
    (t = <MATHTEXTSEPARATOR> | t = <MATHSEPARATOR>) { return t; }
}

Token myDigit():
{
	Token t;
}
{
    (t = <DIGIT0> | t = <DIGIT1>) { return t; }
}

Token latincharacter():
{
    Token t = null;
}
{
	(
        t = <ENGLISHLETTER> | t = <TEXTSYMBOL> | t = <MATHTEXTSEPARATOR> | t = myDigit() //TODO: Fix (don't forget the spaces).
	)
	{ return t; }
}

String brackets() :
{
    Token t = null;
}
{
    (t = <LBRA> | t = <RBRA>) { return getLetterCode(t.image); }
}

String character() :
{
	Token t = null;
	String s;
	boolean space;
}
{
	(t = <ANY> | t = latincharacter() | t = <GREEKLETTER> | t = <DIPHTHONG>)
	{
        String key = t.image;
        String code = getLetterCode(key);
        space = checkforPreviousSpace(t);
        // System.out.print(key);
        if (t.kind == DIGIT0) {
            code = getMathCode("#") + code;
        }
        if (space) {
            return " " + code;
        }
        return code;
	}
}

String character_no_braille() :
{
	Token t = null;
	String s;
	boolean space;
}
{
    (t = latincharacter() | t = <GREEKLETTER> | t = <DIPHTHONG> | t = <SUB>)
	{
        String key = t.image;
        space = checkforPreviousSpace(t);
        // System.out.print(key);
	    if (space) {
	        return " " + key;
        }
	    return key;
	}
}

String bracketcontent() :
{
    Token t;
    String s = "", result;
    boolean space = false;
}
{
    t = <LCB> { space = checkforPreviousSpace(t); }
    /*[LOOKAHEAD(1) <COMMAND>]*/
    // s = basic()
	s = content() // ??
    <RCB>
	{
        if (space) {
            result = " " + s;
        } else {
            result = s;
        }
        return result;
   }
}

String textlatin() :
{
	Token t;
	String s = "", result;
	boolean space = false;
}
{
	(
        t = <TEXTLATIN> { space = checkforPreviousSpace(t); }
	 	s = command_parameter()
	 	{
            String en = getLetterCode("EN");
            s = s.replaceAll("^", en);
            s = s.replaceAll(" ", " " + en);
	    }
	    /*
	    1. Get number of parameters, n, from a symbol table.
        2. Get the parameters in the following fashion:
            for (int param = 0; param < n; param++) {
                command_parameter();
            }
		3. That's all! In this way we can define new commands with a \newcommand command. We just update the symbol table.
		*/
        // [LOOKAHEAD (1) s = command_parameter()] // zero or one parameters. FIX!
	)
    {
        // insert an english text symbol in the beginning and after every space...
        if (space) {
            result = " " + s;
        } else {
            result = s;
        }
        return result;
    }
}


 
// This sucks! Every command actually MUST know its number of parameters.
String textcommand() :
{
	Token t;
	String s = "", result;
	boolean space = false;
}
{
    (
        (
            t = <COMMAND> { space = checkforPreviousSpace(t); }
	        {
				s = getLetterCode(t.image);
//				if (s  == "") { 
//                	definition = commandTable.get(t.image); // TODO: Is this right;
//                	if (definition != null) {
//                	  System.out.println("... or command: " + t.image +
//                        " at line: " + jj_input_stream.getEndLine());
//                	 }
//                	 else {
//                	   s = definition;
//                	 }         	 
//                }
	        }

	        /*
	        1. Get number of parameters, n, from a symbol table.
            2. Get the parameters in the following fashion:
		        for (int param = 0; param < n; param++) {
                    command_parameter();
                }
		    3. That's all! In this way we can define new commands with a \newcommand command.
		       We just update the symbol table.
		    */
            // [LOOKAHEAD (1) s = command_parameter()] // zero or one parameters. FIX!
	    )
	    | s = textlatin() | s = index() | s = label() | s = ref() | s = accent() | s = grave() | s = chapter()
	    | s = section() | s = subsection() | s = textbf() | s = textit() | s = latextonemethallcaps() | input() | newcommand()
	    | textcircled() |ignore()
    )
	{	
        if (space) {
            result = " " + s;
        } else {
            result = s;
        }
        return result;
    }
}

void newcommand() :
{
    String newcommand, definition;
    Token commandToken;
}
{
	<NEWCOMMAND> <LCB> commandToken = <COMMAND> <RCB> <LCB>
	( LOOKAHEAD(basic()) definition = basic() | definition = math() ) <RCB >
	{
        commandTable.put(commandToken.image,definition);
	}
}

void newtheorem() :
{
	StringBuffer name = new StringBuffer(),
	            label = new StringBuffer(),
	            opts = new StringBuffer(),
	            counterLabel = new StringBuffer();
	Token t;
	Theorem theorem = null, counterTheorem = null;
}
{
    // \newtheorem{theorem}{Θεώρημα}[section]
    <NEWTHEOREM> <LCB> ( t = latincharacter() { name.append(t.image); })+ <RCB>
    (
        (
            <LCB>
   	        (
   	            (t = <ENGLISHLETTER> | t = <GREEKLETTER> | t = <DIPHTHONG> | t = myDigit())
   	            {label.append(t.image);}
            )*
   	        <RCB> [ <LBRA> (<ENGLISHLETTER> | myDigit())+ <RBRA> ] //Ignore options, section by default
   	    )
   	    {
   	        theorem = new Theorem(name.toString(), label.toString());
        }
   	    |
   	    (
            <LBRA>
            (
                (t = <ENGLISHLETTER> | t = myDigit()) { counterLabel.append(t.image); }
            )+
            <RBRA> <LCB>
            (
                (t = <ENGLISHLETTER> | t = <GREEKLETTER> | t = <DIPHTHONG> | t = myDigit())
   	    	    { label.append(t.image); }
            )+ <RCB>
   	    )
   	    {
   	      counterTheorem = theorems.get(counterLabel.toString());
   	      theorem = new Theorem(name.toString(), label.toString(), counterTheorem);
   	    }
    )
	{
        // System.out.println("Registering theorem '" + name.toString() +"' " + label.toString());
		theorems.put(name.toString(),theorem);	  
	}
}

String theoremenvironment() :
{
  	String content = "";
  	Token nameToken;
  	Theorem theorem = null;
  	String option = "", label = "";
}
{
	<BEG> nameToken = <ENVNAME> <ENVEND>
    [ LOOKAHEAD(1) <LBRA> option = option() <RBRA> ] [ LOOKAHEAD(1) label = label() ]
	{
	  theorem = theorems.get(nameToken.image);
	    if (theorem == null) {
		System.out.println("Error in line " + jj_input_stream.getEndLine());
		System.out.println("Environment '" + nameToken.image + "' " + " not defined");
		// throw new ParseException();
	    }
    }
    content=content()
	<END> <ENVNAME> <ENVEND>
	{	
	    String lpar = getLetterCode("(");
	    String rpar = getLetterCode(")");
		String optionallabel = "";
		if (!option.equals("")) {
			optionallabel = lpar  + option + rpar;
	    }
        String theoremlabel = "";
        if (theorem != null) {
            theoremlabel = string2Braille(theorem.getLabel());

            if (label.equals("")) {
                StringBuffer theoremNumber = new StringBuffer();
                theoremNumber.append(getLetterCode("#"));

                if (chapter !=0) {
                    theoremNumber.append(string2Braille(Integer.toString(chapter)));
                    theoremNumber.append(getTheoremCode("."));
                }

                theoremNumber.append(string2BrailleTheorem(Integer.toString(section)));
                theoremNumber.append(getTheoremCode("."));
                theoremNumber.append(string2BrailleTheorem(Integer.toString(theorem.getNextCounter())));
                label = theoremNumber.toString();
            }
        }
        return /*"   " + */ theoremlabel  + optionallabel + " " + label + " " + content;
	}
}

String command_parameter() :
{
	String s = "";
}
{
	(s = character() | s = bracketcontent())
	{ return s; }
}

String optioncontent() :
{
	String s = "";
}
{
  (s = character() | s = inlinemath() | s = textcommand() | s = bracketcontent())
  { return s; }
}

String option() :
{
	StringBuffer result = new StringBuffer();
	String s;
}
{
	s = optioncontent() { result.append(s); }
	(LOOKAHEAD(1) s = optioncontent() { result.append(s); })*
	{ return result.toString(); }
}

//Here, content means character or other basic staff.
String basiccontent() :
{
	String s = "";
}
{
  (s = optioncontent() | s = brackets())
  { return s; }
}

String basic() :
{
	StringBuffer result = new StringBuffer();
	String s;
}
{
	s = basiccontent() { result.append(s); }
	(LOOKAHEAD(1) s = basiccontent() { result.append(s); })*
	{ return result.toString(); }
}

String content() :
{
    String s = null;
    StringBuffer buffer = new StringBuffer();
}
{
    (
        s = basic() { buffer.append(s); }
        | s = environment() { buffer.append(s); }
        | s = newline() { buffer.append(s); }
    )*
    { return buffer.toString(); }
}

//Same as the above but with output.
void topcontent() :
{
  	String content = "";
}
{
    (
        (
            content = basic()
            {
                try {
                    output.append(content);
                } catch (Exception e) {
	                e.printStackTrace();
                }
            }
            |
            content = environment()
            {
                try {
                    output.append(content);
                } catch (Exception e) {
	                e.printStackTrace();
                }
            }
            |
            content = newline()
            {
                try {
                    output.append(content);
                } catch (Exception e) {
	                e.printStackTrace();
                }
            }
        )
    )*
}

String  newline() :
{
    String s;
}
{
    ((<TWONEWLINES> (LOOKAHEAD(1) <TWONEWLINES>)*) | <NEWLINE>)
    {
        // System.out.print("\\n");
	    return "   "; // Instead of return "\\n   ";
    }
}

void preamble() :
{}
{
    <DOCUMENTCLASS>
    [LOOKAHEAD(1) <LBRA> (<ENGLISHLETTER> | <TEXTSYMBOL> | myDigit())* <RBRA>]
    <LCB> (latincharacter())+ <RCB>
    (
        <USEPACKAGE> [<LBRA> (<ENGLISHLETTER> | <TEXTSYMBOL> | myDigit())* <RBRA>] <LCB> (latincharacter())+ <RCB>
  	    | newtheorem()
  	    | <TWONEWLINES>
  	    | textcommand()
 	)*
	// Everything in the preamble is ignored (except from the theorem definitions... To be implemented)
}

// I don't think it is useful. Just consume this.
void latex() :
{}
{
    preamble()
    // And other preamble stuff.
    <BEGINDOCUMENT> topcontent() <ENDDOCUMENT>
}

String environment() :
{
    String result;
}
{
    (
        result = enumerate() |
        result = itemize() |
        result = description() |
	    result = mathenvironment() |
	    result=figure() |
	    result = center() |
	    result = quote() |
	    result = theoremenvironment() |
	    result = proof() |
	    result = pspicture()
    )
    { return result; }
}

String proof() :
{
    String content = "", optional = "", theorem = "";
}
{
    <BEGINPROOF>
    // By convention, label is the first command!! It should be optional!!
    content = content()
    <ENDPROOF>
	{
        String q = getLetterCode("\\textit-open") + string2Braille("Αποδειξη") + getLetterCode("\\textit-close");
	    return q + content + getMathCode("\\Box") + " ";
    }
}

String pspicture() :
{
    Token t;
    String s = "";
    StringBuilder buf = new StringBuilder("");
}
{
    <BEGINPSPICTURE>
    (
        (
            t = mathcharacter() { buf.append(t.image); }
            | t = <COMMAND>     { buf.append(t.image); }
            | t = <LCB>         { buf.append(t.image); }
            | t = <RCB>         { buf.append(t.image); }
            | t = <SUP>         { buf.append(t.image); }
            | t = <SUB>         { buf.append(t.image); }
            | t = <NEWLINE>     { buf.append("\\n"); }
            | t = <TWONEWLINES> { buf.append("\\n\\n"); }
            )+
        | s = inlinemath() { buf.append(s); }
    )+ { s = buf.toString(); }
    <ENDPSPICTURE>
	{
	    String result = "\\begin{pspicture}" + s + "\\end{pspicture}";
	    picture++;
	    DataDumper.writePicture(picture, preamble.getStart() + result + preamble.getEnd());
	    return "";
    }
}

String quote() :
{
    String content = "", optional = "", theorem = "";
}
{
    <BEGINQUOTE>  /*[LOOKAHEAD(1) <LBRA>  optional = option() <RBRA>] */
    // By convention, label is the first command!! It should be optional!!
    content = content()
	<ENDQUOTE>
	{
        String q = getLetterCode("'");
        return q + content + q;
    }
}

String figure() :
{
    String label = null, caption = null, s="";
}
{
    <BEGINFIGURE> [LOOKAHEAD(1) <LBRA> option() <RBRA>]
  	[caption = caption() [label = label()] ] {
		if (null == label) {
			System.out.println("CAPTION WITHOUT LABEL AT LINE " + jj_input_stream.getEndLine());
		}
		else { 		
  	    	s = "\n" + string2Braille("Σχήμα ") + label + string2Braille(":") + " " + caption +"\n";
		}
  	 }
    <ENDFIGURE>
	{ return  s; }
}

String caption():
{
	String caption;
}
{
  	< CAPTION > caption = command_parameter() {
  	  return caption;
  	 }
}

String center() :
{
    String content = "", theorem = "";
}
{
    <BEGINCENTER>
    // By convention, label is the first command!! It should be optional!!
    content = content() <ENDCENTER>
    { return content; }
}

String item() :
{
    String option = "";
    StringBuffer buffer = new StringBuffer();
}
{
    <ITEM>
    [LOOKAHEAD(1) <LBRA> option = option() <RBRA> { buffer.append(option); }]
    { return buffer.toString(); }
}
 
String enumerate() :
{
    int counter = 1;
    StringBuffer buffer = new StringBuffer();
    String itemString, contentString;
}
{
    <BEGINENUMERATE> { enumeratedepth++; }
    (
        itemString = item()
        {
		    buffer.append("\n");
	        if (itemString.equals("")) {
		        if (enumeratedepth == 2) {
	  		        buffer.append(string2Braille(IntegerConversion.integerToGreek(counter++)));
                    buffer.append(getLetterCode("."));
                } else if (enumeratedepth == 3) {
		            buffer.append(string2Braille(IntegerConversion.integerToRomanNumeral(counter++)));
	  		        buffer.append(getLetterCode("."));
		        } else { // enumeratedepth = 1 or 4, 5, 6, ...
		  	        buffer.append(getLetterCode("#"));
	  		        buffer.append(string2Braille(Integer.toString(counter++)));
	  		        buffer.append(getLetterCode("."));
	 	        }
	        } else {
	  	        buffer.append(itemString );
	        }
		    buffer.append(getLetterCode(" "));
	    }
		contentString = content()
	    {
		    buffer.append(contentString);
	        // System.out.print("\\n");
	    }
	)*
	<ENDENUMERATE>  { enumeratedepth--; }
	{ return buffer.toString()+ "\n   "; }
}

String itemize() :
{
    StringBuffer buffer = new StringBuffer();
    String itemString, contentString;
}
{
    <BEGINITEMIZE>
    (
        itemString = item()
        {
            buffer.append("\n");
            if (itemString.equals("")) {
                buffer.append(getMathCode("\\bullet"));
            }
	        buffer.append(itemString );
	    }
		contentString = content()
	    {
            buffer.append(contentString);
            // System.out.print("\\n");
	    }
	)*
    <ENDITEMIZE>
    { return buffer.toString() + "\n   "; }
}

String description() :
{
    StringBuffer buffer = new StringBuffer();
    String itemString, contentString;
}
{
    <BEGINDESCRIPTION>
	(
	    itemString = item()
	    {
		    buffer.append("\n");
            buffer.append(itemString );
            buffer.append(getLetterCode("."));
            buffer.append(" ");
	    }
		contentString = content()
	    {
            buffer.append(contentString);
	    }
	)*
    <ENDDESCRIPTION>
    { return buffer.toString()+ "\n   "; }
}

String mathenvironment() :
{
    String result = "";
}
{
    (
        (
            (< MATHBEGIN > |< MATHBEND >)
		    result = math()
            ( < MATHEND > |< MATHBEND >)
        )
        |
        result = eqnarray_align()
    )
	{ return "\n" + result + "\n"; }
}

String inlinemath() :
{
    Token t;
    String s = "";
    boolean space;
}
{
    t = <INLINEMATH> { space = checkforPreviousSpace(t); }
    s = math()
    <INLINEMATH>
    {
        if (space) {
            return " " + s;
        }
        return s;
    }
}

String index() :
{
    Token t;
    String s = "";
    boolean space;
}
{
    t = <INDEX> { space = checkforPreviousSpace(t); }
	command_parameter()// ignore both parameters...
	command_parameter()
    {
        if (space) {
            return " " + s;
        }
        return s;
    }
}

 // Are you sure that label does this??
String label() :
{
    Token t;
    String s = "";
    boolean space;
    StringBuffer buffer = new StringBuffer();
}
{
    t = <LABEL> { space = checkforPreviousSpace(t); }
	(
        s = character_no_braille() |
        <LCB> (s = character_no_braille() { buffer.append(s); })+ { s = buffer.toString(); } <RCB>
    )
    {
        // System.out.println("\nLABEL: " + s);
        String label = labeltable.get(s);
        // System.out.print( " " + label + " ");
        if (label != null) {
		    label = getMathCode("#")+string2BrailleTheorem(label);
        } else {
		    System.out.println("LABEL: " + s + " NOT FOUND");
	        label = getLetterCode("?");
	  	} // In case code is not found...
	    if (space) {
    	    return " " + label;
        }
        return label;
    }
}

String ref() :
{
    Token t;
    String s = "";
    boolean space;
    StringBuffer buffer = new StringBuffer();
}
{
    t = <REF> { space = checkforPreviousSpace(t); }
    (
        s = character_no_braille() |
	    <LCB> (s = character_no_braille() { buffer.append(s); })+ { s = buffer.toString(); } <RCB>
    )
    {
	    // System.out.println("\nLABEL: " + s);
	    String label = labeltable.get(s);
	    if (label != null) {
		    label = string2BrailleTheorem(label);
        } else {
		    label = getLetterCode("?");
        }
	    if (space) {
    	    return " " + getMathCode("#") + label;
        }
    
	    if (t.image.equals("\\eqref")) {
		    label = getLetterCode("(") + label + getLetterCode(")");
        }
	    return label;
    }
}

String textbf() :
{
    Token t;
    boolean space;
    String s = null;
}
{
    t = <TEXTBF> { space = checkforPreviousSpace(t); }
    (
        s = character() { s = getLetterCode("\\textbf") + s; } |
	    s = bracketcontent() { s = bold(s); }
    )
    {
        if (space) {
    	    return " " + s;
        }
        return s;
    }
}

String ignore() :
{
    Token t;
    boolean space;
    String s = null;
}
{
    (t = <TEXTSC> | t = <HUGE>) { space = checkforPreviousSpace(t); }
    (
        s = character()
        {
            // s = getLetterCode("\\textit") + s;
	    }
	    |
        s = bracketcontent()
        {
            // s = "\u2820\u2804\u2838" + s + "\u2838\u2820\u2804";
	    }
    )
    {
        if (space) {
    	    return " " + s;
        }
        return s;
    }
}

String textit() :
{
  Token t;
  boolean space;
  String s = null;
}
{
    t = <TEXTIT> { space = checkforPreviousSpace(t); }
    (
        s = character() { s = getLetterCode("\\textit") + s; } |
	    s = bracketcontent()
	    {
	        // TODO: Fix the following...
	        s = getLetterCode("\\textit-open")+ s + getLetterCode("\\textit-close");
	    }
    )
    {
	    if (space) {
    	    return " " + s;
        }
        return s;
    }
}

String textcircled() :
{
  Token t;
  boolean space;
  String s = null;
}
{
    t = <TEXTCIRCLED> { space = checkforPreviousSpace(t); }
    (
        (s = character() |
	    	s = bracketcontent())
	    {
	        // TODO: Fix the following...
	        s = getLetterCode("\\textcircled-open")+ s + getLetterCode("\\textcircled-close");
	    }
    )
    {
	    if (space) {
    	    return " " + s;
        }
        return s;
    }
}

String latextonemethallcaps() :
{
	Token t;
	String s = null;
	boolean space;
}
{
	t = <LTNALLCAPS> { space = checkforPreviousSpace(t); }
	(s = character() |
	    	s = bracketcontent())
	    	{
		s = getLetterCode("b-allcaps") + s + getLetterCode("e-allcaps");
 	if (space) {
    	    return " " + s;
        }
		return s;
	    	  }
	
}

void input() :
{
    String s, filepath = "";
    StringBuffer buffer = new StringBuffer();
}
{
    (
        (
            <INPUT> <LCB> (s = character_no_braille() { buffer.append(s); })+ <RCB>
            { filepath = buffer.toString(); }
        )
	    |
        (
	        <INCLUDE> <LCB> (s = character_no_braille() { buffer.append(s); })+ <RCB>
	        { filepath = buffer.toString() + ".tex"; }
        )
    )
    {
        try {
	        System.out.println("PARSING FILE: " + filepath);
	        FileInputStream is = new FileInputStream(filepath);
            InputStreamReader fis = new InputStreamReader(is, "ISO-8859-7");
	        Latex parser = new Latex (fis);
            parser.topcontent();
            System.out.println("EXITING PARSING: " + filepath);
            fis.close();
            is.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
	}
}

String accent() :
{
    String s = "", c = "";
}
{
    <ACCENT> (c = character_no_braille() | <LCB> c = character() (character_no_braille())* <RCB>)
    {
        if (c.equals("e")) {
            s = getLetterCode("e-grave");
        }
		// ...
        return s;
    }
}

String grave() :
{
    String s = "", c = "";
}
{
    <GRAVEACCENT> (c = character_no_braille() | <LCB> c = character() (character_no_braille())* <RCB>)
    {
        if (c.equals("e")) {
			 s = getLetterCode("e-accent");
         }
		// ...
        return s;
    }
}

String chapter() :
{
    String s = "", label = "";
}
{
    <CHAPTER> s = command_parameter() [LOOKAHEAD(1) label = label()]
    {
        try {
            output.flush(); // We are always sure that the existing output stream is not closed...
            output.close();
            parsedChapters.put(chapter, output.toString());
            output = new StringWriter();
	    } catch(IOException ioe) {
		    ioe.printStackTrace();
        }
        chapter++;
        section = 0;
        subsection = 0;
        if (label.equals("")) {
	  	    label = getLetterCode("#") + string2Braille(Integer.toString(chapter));
        }
  	    return "\n" + string2Braille("Κεφάλ") + getLetterCode("αι") + string2Braille("ο ") + label + s + "\n";
    }
}

String section() :
{
    String s = "", label = "", option = "";
}
{
    <SECTION> [<LBRA> option = option() <RBRA>] s = command_parameter() [LOOKAHEAD(1) label = label()]
    {
        section++;
        subsection = 0;
        for (Theorem theorem: theorems.values()) {
            theorem.resetCounter();
        }
        if (label.equals("")) {
	  	    label = getLetterCode("#") +	string2Braille(Integer.toString(section));
        }
        return option + " " + label + s + "\n   ";
  	}
}

String subsection() :
{
    String s = "", label = "", option = "";
}
{
    <SUBSECTION> [<LBRA> option = option() <RBRA>] s = command_parameter() [LOOKAHEAD(1) label = label()]
    {
        subsection++;
        return option + " " + label + s + "\n";
  	}
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////// MATHEMATICS /////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////



// put the stuff here...
String math() :
{
    Expression e;
    String s = "", label = "";
}
{
    //consider that a label can be only placed in the beginning or in the end of a math expression:
    [label = label()]
    e = mathexpression()
    [label = label()]
	{
        e.assignFractionLevel();
        e.assignOtherLevels();
        s = e.getBraille();
	}
	{
		if (!label.equals("")) {
			s = s + getMathCode("(") + label + getMathCode(")");
        }
        return  s ;
	}
}

Token mathcharacter() :
{
  	Token t;
}
{
    // TODO: We should not allow diphthongs in math mode. Put it out as soon as mathrm etc. are implemented.
    (
        t = <ENGLISHLETTER> | t= <TEXTSYMBOL> | t = myDigit() | t = <GREEKLETTER> |
        t = <DIPHTHONG> | t = <MATHSYMBOL> | t = mathDelimiter()
    )
    { return t; }
}

Token mathcharacter_no_brackets() :
{
  	Token t;
}
{
    // TODO: We should not allow diphthongs in math mode. Put it out as soon as mathrm etc. are implemented.
    (
        t = <ENGLISHLETTER> | t = <TEXTSYMBOL> | t = myDigit() |
        t = <GREEKLETTER> | t = <DIPHTHONG> | t = <MATHSYMBOL> | t = mathDelimiter_no_brackets()
    )
    { return t; }
}
 
// A math expression should not be empty...
Expression mathexpression() :
{
    Expression exp;
    MathExpression mex = new MathExpression(table);
	Expression exp1, exp2;
}
{
    (
        LOOKAHEAD(simpleexpression())(exp = simpleexpression()  {   mex.addChild(exp); })
    )+
	{ return mex; }
}

Expression mathexpression_no_brackets() :
{
    Expression exp;
    MathExpression mex = new MathExpression(table);
}
{
	(
        LOOKAHEAD(simpleexpression_no_brackets())(exp = simpleexpression_no_brackets()  {  mex.addChild(exp); })
    )+
	{ return mex; }
}

Expression atomicmath() :
{
    Token t;
    Expression exp = null;
}
{
    (
        (t = <COMMAND> | t = mathcharacter())
        {
	        String s = t.image.toString();
	        if (t.kind == DIGIT0) {
		        s =  "#" + s; // see NemethTable (hack...)
            }
            exp = new SimpleExpression(s, table);
        }
	    | <LCB> exp = mathexpression() <RCB>
		// <LCB> [exp = mathexpression()] <RCB>, if you need empty expressions!
    )
    { return exp; }
}

Expression parameterexpression() :
{
    Token t;
    Expression exp = null;
}
{
    (
        (t = <COMMAND> | t = mathcharacter())
        {
            String s = t.image.toString();
	        if (t.kind == DIGIT0) {
		        s = "#" + s; // see NemethTable (hack...)
            }
            exp = new SimpleExpression(s, table);

            if (DEFAULT != token_source.curLexState) {
                Token root = new Token(), last = root;
                root.next = null;

                // First, we build a list of tokens to push back, in backwards order
                while (token.next != null) {
                    Token to = token;
                    // Find the token whose token.next is the last in the chain
                    while (to.next != null && to.next.next != null) {
                        to = to.next;
                    }

                    // put it at the end of the new chain
                    last.next = to.next;
                    last = to.next;

                    // If there are special tokens, these go before the regular tokens,
                    // so we want to push them back onto the input stream in the order
                    // we find them along the specialToken chain.
                    if (to.next.specialToken != null) {
                        Token tt = to.next.specialToken;
                        while (tt != null) {
                            last.next = tt;
                            last = tt;
                            tt.next = null;
                            tt = tt.specialToken;
                        }
                    }
                    to.next = null;
                };

                while (root.next != null) {
                    jj_input_stream.backup(root.next.image.length());
                    root.next = root.next.next;
                }
                jj_ntk = -1;
                token_source.SwitchTo(DEFAULT);
            }
        }
	    | <LCB> exp = mathexpression() <RCB>
	    // <LCB> [exp = mathexpression()] <RCB>, if you need empty expressions!
    )
    { return exp; }
}

Expression atomicmath_no_brackets() :
{
    Token t;
    Expression exp = null;
}
{
    (
        (t = <COMMAND> | t = mathcharacter_no_brackets())
        {
            String s = t.image.toString();
            if (t.kind == DIGIT0) {
                s = "#" + s; // see NemethTable (hack...)
            }
            exp = new SimpleExpression(s, table);
        }
	    | <LCB> exp = mathexpression_no_brackets() <RCB>
	    // <LCB> [exp = mathexpression()] <RCB>, if you need empty expressions!
    )
    { return exp; }
}

Expression parameterexpression_no_brackets() :
{
    Token t;
    Expression exp = null;
}
{
    (
        (t = <COMMAND> | t = mathcharacter_no_brackets())
        {
            String s = t.image.toString();
	        if (t.kind == DIGIT0) {
		        s = "#" + s; // see NemethTable (hack...)
            }
            exp = new SimpleExpression(s, table);

            if (DEFAULT != token_source.curLexState) {
                Token root = new Token(), last = root;
                root.next = null;

                // First, we build a list of tokens to push back, in backwards order
                while (token.next != null) {
                    Token to = token;
                    // Find the token whose token.next is the last in the chain
                    while (to.next != null && to.next.next != null) {
                        to = to.next;
                    }

                    // put it at the end of the new chain
                    last.next = to.next;
                    last = to.next;

                    // If there are special tokens, these go before the regular tokens,
                    // so we want to push them back onto the input stream in the order
                    // we find them along the specialToken chain.

                    if (to.next.specialToken != null) {
                        Token tt = to.next.specialToken;
                        while (tt != null) {
                            last.next = tt;
                            last = tt;
                            tt.next = null;
                            tt = tt.specialToken;
                        }
                    }
                    to.next = null;
                };

                while (root.next != null) {
                    jj_input_stream.backup(root.next.image.length());
                    root.next = root.next.next;
                }
                jj_ntk = -1;
                token_source.SwitchTo(DEFAULT);
            }
        }
	    | <LCB> exp = mathexpression_no_brackets() <RCB>
	    // <LCB> [exp = mathexpression()] <RCB>, if you need empty expressions!
    )
    { return exp; }
}

Expression basicexpression() :
{
    Expression exp=null;
}
{
    (
        exp = mathcommand() |
        exp = atomicmath() |
        exp = array() |
        exp = cases() |
		exp = pmatrix()|
		exp = cases_command() |
        exp = split() |
        exp = leftright() | /* This could possibly be in atomic math non-terminal. Check. */
        exp = modifiedMathDelimiter() /* This could possibly be in atomic math non-terminal. Check. */
    )
    { return exp; }
}

Expression basicexpression_no_brackets() :
{
    Expression exp=null;
}
{
    (
        exp = mathcommand() |
        exp = atomicmath_no_brackets() |
        exp = array() |
        exp = leftright() |
        exp = modifiedMathDelimiter()
    )
    { return exp; }
}
 
Expression simpleexpression() :
{
    Token t;
    Expression exp = null, exp1 = null, exp2, exp3;
}
{
    (
        (
	        exp = basicexpression()
		    [LOOKAHEAD(1) (
                (
                    <SUP> exp2 = basicexpression() { exp1 = exp; exp = new Sup(exp1, exp2, table);  }
                    [LOOKAHEAD(1) <SUB> exp3 = basicexpression() { exp = new SubSup(exp1, exp3, exp2, table); }]
                )
                |
                (
                    <SUB> exp2 = basicexpression() { exp1 = exp; exp = new Sub(exp1, exp2, table); }
                    [LOOKAHEAD(1) <SUP> exp3 = basicexpression() { exp = new SubSup(exp1, exp2, exp3, table); }]
                )
            )]
        )
        |
		(
            { exp = new EmptyExpression(); }
		    (
		        (
		            <SUP> exp2 = basicexpression() { exp1 = exp; exp = new Sup(exp1, exp2, table); }
		            [LOOKAHEAD(1) <SUB> exp3 = basicexpression() { exp = new SubSup(exp1, exp3, exp2, table); }]
                )
			    |
			    (
			        <SUB> exp2 = basicexpression() { exp1 = exp; exp = new Sub(exp1, exp2, table); }
		            [LOOKAHEAD(1) <SUP> exp3 = basicexpression() { exp = new SubSup(exp1, exp2, exp3, table); }]
                )
		    )
        )
    )
    { return exp; }
}

Expression simpleexpression_no_brackets() :
{
    Token t;
    Expression exp = null, exp1 = null, exp2, exp3;
}
{
    (
        (
	        exp = basicexpression_no_brackets()
		    [ LOOKAHEAD(1) (
		        (
		            <SUP> exp2 = basicexpression_no_brackets()
		            { exp1 = exp; exp = new Sup(exp1, exp2, table); }
		            [LOOKAHEAD(1) <SUB> exp3 = basicexpression_no_brackets() { exp = new SubSup(exp1, exp3, exp2, table); }]
                )
			    |
			    (
			        <SUB> exp2 = basicexpression_no_brackets()
			        { exp1 = exp; exp = new Sub(exp1, exp2, table); }
		            [LOOKAHEAD(1) <SUP> exp3=basicexpression_no_brackets() { exp = new SubSup(exp1, exp2, exp3, table); }]
                )
		    )]
        )
        |
		(
            { exp = new EmptyExpression(); }
		    (
		        (
		            <SUP> exp2 = basicexpression_no_brackets()
		            { exp1 = exp; exp = new Sup(exp1, exp2, table); }
                    [LOOKAHEAD(1) <SUB> exp3 = basicexpression_no_brackets() { exp = new SubSup(exp1, exp3, exp2, table); }]
                )
			    |
			    (
			        <SUB> exp2 = basicexpression_no_brackets()
			        { exp1 = exp; exp = new Sub(exp1, exp2, table); }
		            [LOOKAHEAD(1) <SUP> exp3=basicexpression_no_brackets() { exp = new SubSup(exp1, exp2, exp3, table); }]
                )
		    )
        )
    )
    { return exp; }
}


Expression mathcommand() :
{
    Expression exp = null;
}	
{
    (
        exp = sqrt() | exp = frac() | exp = textinmath() |
        exp = latinmath() | exp = mathbb() | exp = mathcal() |
        exp = underbrace() | exp = overbrace() | exp = dot() |
        exp = overline() | exp = underline() | exp = tilde() | exp = vec() |
        exp = widetilde() | exp = lenqno() | exp = binom() | exp = hat() |
        exp = bar() | exp = stackrel() | exp = check() | exp = acute() | exp = gravemath() |
        exp = breve() | exp = ddot() | exp = mathring() | 
        exp = ignorecommand()
    )
    { return exp; }
}

Vector<Expression> row() :
{
    Expression exp;
    Vector<Expression> expressions =  new Vector<Expression>();
}
{
    [exp=mathexpression() { expressions.add(exp); }]
    ( <AMPERSAND> [exp = mathexpression() {expressions.add(exp); }] )*
	{ return expressions; }
}

Expression[] arrayrow(int cols) :
{
  	Expression exp;
  	Expression [] expressions =  new Expression[cols];
  	int col = 0;
}
{
    [exp=mathexpression() { expressions[col] = exp; }]
    ( <AMPERSAND> [exp = mathexpression() {expressions[++col]=exp; }] )*
	{ return expressions; }
}

Expression cases() :
{
    Expression[] row = null;
    Vector<Expression[]> rows = new Vector<Expression[]>();
    int cols = 0;
}
{
    <BEGINCASES> row = arrayrow(2) { rows.add(row); }
    (<NEWLINE> row = arrayrow(2) { rows.add(row); })* <ENDCASES>
    {
        Array array  = new Array(rows, table);
        DelimiterExpression dexp = new DelimiterExpression("\\{",".", array, table);
        return dexp;
    }
}


Expression pmatrix() :
{
    Expression[] row = null;
    Vector<Expression[]> rows = new Vector<Expression[]>();
    int cols = 0;
}
{
    <BEGINPMATRIX> row = arrayrow(2) { rows.add(row); }
    (<NEWLINE> row = arrayrow(2) { rows.add(row); })* <ENDPMATRIX>
    {
        Array array  = new Array(rows, table);
        DelimiterExpression dexp = new DelimiterExpression("(",")", array, table);
        return dexp;
    }
}

Expression bmatrix() :
{
    Expression[] row = null;
    Vector<Expression[]> rows = new Vector<Expression[]>();
    int cols = 0;
}
{
    <BEGINPMATRIX> row = arrayrow(2) { rows.add(row); }
    (<NEWLINE> row = arrayrow(2) { rows.add(row); })* <ENDPMATRIX>
    {
        Array array  = new Array(rows, table);
        DelimiterExpression dexp = new DelimiterExpression("\\[","\\]", array, table);
        return dexp;
    }
}


Expression cases_command() :
{
    Expression[] row = null;
    Vector<Expression[]> rows = new Vector<Expression[]>();
    int cols = 0;
}
{
    <CASES> <LCB>row = cases_row() { rows.add(row); }
    (<CR> [row = cases_row() { rows.add(row); }])*    <RCB> // A final <CR> at the end is permitted...
    {
        Array array  = new Array(rows, table);
        DelimiterExpression dexp = new DelimiterExpression("\\{",".", array, table);
        return dexp;
    }
}

Expression[] cases_row() :
{
  	Expression exp;
	String s;
  	Expression [] expressions =  new Expression[2];
}
{
    exp=mathexpression() { expressions[0] = exp; }
     <AMPERSAND> s = content() {expressions[1] = new TextMathExpression(s,table); } // Careful!
	{ return expressions; }
}

Array array() :
{
    Expression[] row = null;
    Vector<Expression[]> rows = new Vector<Expression[]>();
    int cols = 0;
}
{
    "\\begin{array}" <LCB> (<ENGLISHLETTER> { cols++; })* <RCB>
    row = arrayrow(cols) { rows.add(row); }
    (<NEWLINE> row = arrayrow(cols) { rows.add(row); })*
    "\\end{array}"
    { return new Array(rows, table); }
}

MathExpression split() :
{
    Vector<Expression> r;
    MathExpression math = new MathExpression(table);
}
{
    <BEGINSPLIT>
    r = row()
    {
        for (Expression exp : r) {
		    math.addChild(exp);
        }
        math.addChild(new SimpleExpression(" ", table));
    }
    [label() { /* ignore label */ }]
    (
        <NEWLINE> [LOOKAHEAD(1) <LBRA> mathexpression_no_brackets() <RBRA>]
        { /* buffer.append(" "); */ }
        r = row()
        {
            for (Expression exp : r) {
        		// buffer.append(exp.getBraille());
		        math.addChild(exp);
            }
            math.addChild(new SimpleExpression(" ", table));
        }
        [label() { /* ignore label */ }]
    )*
    <ENDSPLIT>
    {
        return math;
        // buffer.toString();
    }
}

String eqnarray_align() :
{
    Vector<Expression> r;
    StringBuffer buffer = new StringBuffer();
    String label;
}
{
    ("\\begin{eqnarray}" | "\\begin{eqnarray*}" | "\\begin{align}" | "\\begin{align*}")
 	[LOOKAHEAD(1) label = label()] //TODO: this label is ignored!!
    r = row()
    {
        for (Expression exp : r) {
    		buffer.append(exp.getBraille());
        }
    }
    [label = label() { buffer.append(" " + getMathCode("(") + label+ getMathCode(")")); }]
    (
        <NEWLINE> [LOOKAHEAD(1) <LBRA> mathexpression_no_brackets() <RBRA>]
        { buffer.append(" "); }
        r = row()
        {
            for (Expression exp : r) {
		        buffer.append(exp.getBraille());
            }
        }
        [label = label() { buffer.append(" " + getMathCode("(") + label+ getMathCode(")")); }]
    )* // ignore labels at the moment.
    ("\\end{eqnarray}" | "\\end{eqnarray*}" | "\\end{align}" | "\\end{align*}")
    { return buffer.toString(); }
}


Fraction frac() :
{
    Expression nom, denom;
}
{
    <FRAC> nom = parameterexpression() denom = parameterexpression()
    { return new Fraction(nom, denom, table); }
}

Sqrt sqrt() :
{
    Expression root;
    Expression rank = null;
    Token t;
}
{
    <SQRT> [LOOKAHEAD(1) <LBRA> rank = mathexpression_no_brackets() <RBRA> {}]
	root = parameterexpression()
	{
	    if (rank != null) {
	        return new Sqrt(root, rank, table);
        }
	    return new Sqrt(root, table);
    } //  Seems to work...
}

// This is a special kind of array...
Expression leftright() :
{
  Token t1, t2;
  Expression exp;
}
{
    <LEFT> t1 = mathDelimiter() exp = mathexpression() <RIGHT> t2 = mathDelimiter()
  	{ return new DelimiterExpression(t1.image, t2.image, exp, table); }
}

Expression latinmath() :
{
    Expression exp;
    String s;
}
{
    (<TEXTLATIN>) s = command_parameter()
	{
        String en = getLetterCode("EN");
        s = en + s;
        return new TextMathExpression(s, table);
	}
}

Expression textinmath() :
{
    Expression exp;
    String s;
}
{
    (<TEXTRM> | <INTERTEXT> | <HBOX>) s = command_parameter()
	{ return new TextMathExpression(s, table); }
}

MathExpression mathbb() :
{
    Expression exp;
    MathExpression newexp;
}
{
    <MATHBB> exp = parameterexpression()
	{
        newexp = new MathExpression(table);
	  	newexp.addChild(new SimpleExpression("\\mathbb", table));
	  	newexp.addChild(exp);
		return newexp;
	}
}

MathExpression mathcal() :
{
    Expression exp;
    MathExpression newexp;
}
{
    <MATHCAL> exp = parameterexpression()
	{
	  	newexp = new MathExpression(table);
	  	newexp.addChild(new SimpleExpression("\\mathcal", table));
	  	newexp.addChild(exp);
		return newexp;
	}
}

MathExpression breve() :
{
    Expression exp;
    MathExpression newexp;
}
{
    <BREVE> exp = parameterexpression()
	{
	  	newexp = new MathExpression(table);
	  	newexp.addChild(exp);
	  	newexp.addChild(new SimpleExpression("\\breve", table));
	  	
		return newexp;
	}
}

MathExpression ddot() :
{
    Expression exp;
    MathExpression newexp;
}
{
    <DDOT> exp = parameterexpression()
	{
	  	newexp = new MathExpression(table);
	  	newexp.addChild(exp);
	  	newexp.addChild(new SimpleExpression("\\ddot", table));
	  	
		return newexp;
	}
}

MathExpression mathring() :
{
    Expression exp;
    MathExpression newexp;
}
{
    <MATHRING> exp = parameterexpression()
	{
	  	newexp = new MathExpression(table);
	  	newexp.addChild(exp);
	  	newexp.addChild(new SimpleExpression("\\mathring", table));
	  
		return newexp;
	}
}

MathExpression vec() :
{
  Expression exp; MathExpression newexp;
}
{
	< VEC > exp = parameterexpression()
	{
	  	newexp = new MathExpression(table);

	  	newexp.addChild(new SimpleExpression("\\vec-begin",table));
		newexp.addChild(exp);
	  	newexp.addChild(new SimpleExpression("\\vec-end",table));
	  	
		return newexp;
	}
}

MathExpression hat() :
{
    Expression exp;
    MathExpression newexp;
}
{
    <HAT> exp = parameterexpression()
	{
	  	newexp = new MathExpression(table);
		newexp.addChild(exp);
	  	newexp.addChild(new SimpleExpression("\\hat", table));
		return newexp;
	}
}

MathExpression overline() :
{
    Expression under, sub = null;
    MathExpression newexp;
}
{
	<OVERLINE> under = parameterexpression()
	{
	  	newexp = new MathExpression(table);
	  	newexp.addChild(new SimpleExpression("\\overline-begin", table));
	  	newexp.addChild(under);
		newexp.addChild(new SimpleExpression("\\overline-end", table));
    }
	{ return newexp; }
}

MathExpression underline() :
{
    Expression under, sub = null;
    MathExpression newexp;
}
{
	<UNDERLINE> under = parameterexpression()
	{
	  	newexp = new MathExpression(table);
	  	newexp.addChild(new SimpleExpression("\\underline-begin", table));
	  	newexp.addChild(under);
		newexp.addChild(new SimpleExpression("\\underline-end", table));
    }
	{ return newexp; }
}

MathExpression dot() :
{
    Expression under, sub = null;
    MathExpression newexp;
}
{
	<DOT> under = parameterexpression()
	{
	  	newexp = new MathExpression(table);
	  	newexp.addChild(new SimpleExpression("\\dot-begin", table));
	  	newexp.addChild(under);
		newexp.addChild(new SimpleExpression("\\dot-end", table));
    }
	{ return newexp; }
}


MathExpression binom() :
{
    Expression under, sub = null;
    MathExpression newexp;
}
{
	< BINOM > under = parameterexpression() sub = parameterexpression()
	{
	  	newexp = new MathExpression(table);
	  	newexp.addChild(new SimpleExpression("(", table));
	  	newexp.addChild(under);
		newexp.addChild(new SimpleExpression("\\binom", table));
		newexp.addChild(sub);
		newexp.addChild(new SimpleExpression(")", table));
    }
	{ return newexp; }
}

Expression ignorecommand() :
{
    Expression exp = null;
}
{
	(<TEXTSC>) exp = parameterexpression()
	{ return exp; }
}

MathExpression underbrace() :
{
    Expression under, sub = null;
    MathExpression newexp;
}
{
	<UNDERBRACE> under = parameterexpression()
	{
	  	newexp = new MathExpression(table);
	  	newexp.addChild(new SimpleExpression("\\underbrace-begin", table));
	  	newexp.addChild(under);
		newexp.addChild(new SimpleExpression("\\underbrace-middle", table));
    }
    [LOOKAHEAD(1) <SUB> sub = parameterexpression()
	{
		newexp.addChild(sub);
		newexp.addChild(new SimpleExpression("\\underbrace-end", table));
		newexp.addChild(new SimpleExpression(" ", table));
	}]
	{ return newexp; }
}

MathExpression overbrace() :
{
    Expression over, sup = null;
    MathExpression newexp;
}
{
    <OVERBRACE> over = parameterexpression()
	{
	  	newexp = new MathExpression(table);
	  	newexp.addChild(new SimpleExpression("\\overbrace-begin", table));
	  	newexp.addChild(over);
		newexp.addChild(new SimpleExpression("\\overbrace-middle", table));
    }
    [LOOKAHEAD(1) <SUP> sup = parameterexpression()
	{
		newexp.addChild(sup);
		newexp.addChild(new SimpleExpression("\\overbrace-end", table));
		newexp.addChild(new SimpleExpression(" ", table));
	}]
	{ return newexp; }
}

MathExpression tilde() :
{
    Expression over, sup = null;
    MathExpression newexp;
}
{
    <TILDE> over = parameterexpression()
    {
        newexp = new MathExpression(table);
	  	newexp.addChild(over);
	  	newexp.addChild(new SimpleExpression("\\tilde", table));
    }
	{ return newexp; }
}

MathExpression lenqno() :
{
    Expression over, sup = null;
    MathExpression newexp;
}
{
    <LENQNO>  over = parameterexpression()
	{
	  	newexp = new MathExpression(table);
	 	newexp.addChild(new SimpleExpression("\\lenqno", table));
	  	newexp.addChild(over);
    }
	{ return newexp; }
}

MathExpression widetilde() :
{
    Expression over, sup = null;
    MathExpression newexp;
}
{
    <WIDETILDE> over = parameterexpression()
	{
	  	newexp = new MathExpression(table);
	  	newexp.addChild(new SimpleExpression("\\widetilde-begin", table));
	  	newexp.addChild(over);
	  	newexp.addChild(new SimpleExpression("\\widetilde-begin", table));
    }
	{ return newexp; }
}

MathExpression bar() :
{
    Expression over, sup = null;
    MathExpression newexp;
}
{
    <BAR> over = parameterexpression()
	{
	  	newexp = new MathExpression(table);
	  	newexp.addChild(over);
	  	newexp.addChild(new SimpleExpression("\\bar", table));
    }
	{ return newexp; }
}

MathExpression check() :
{
    Expression over, sup = null;
    MathExpression newexp;
}
{
    <CHECK>  over = parameterexpression()
	{
	  	newexp = new MathExpression(table);
	  	newexp.addChild(over);
	  	newexp.addChild(new SimpleExpression("\\check", table));
    }
	{ return newexp; }
}

MathExpression acute() :
{
    Expression over, sup = null;
    MathExpression newexp;
}
{
    <ACUTE>  over = parameterexpression()
	{
	  	newexp = new MathExpression(table);
	  	newexp.addChild(over);
	  	newexp.addChild(new SimpleExpression("\\acute", table));
    }
	{ return newexp; }
}

MathExpression gravemath() :
{
    Expression over, sup = null;
    MathExpression newexp;
}
{
    <GRAVE> over = parameterexpression()
	{
	  	newexp = new MathExpression(table);
	  	newexp.addChild(over);
	  	newexp.addChild(new SimpleExpression("\\grave", table));
    }
	{ return newexp; }
}

MathExpression stackrel() :
{
    Expression exp1, exp2;
    MathExpression newexp;
}
{
    <STACKREL> exp1  = parameterexpression() exp2 = parameterexpression()
	{
	  	newexp = new MathExpression(table);
	  	newexp.addChild(new SimpleExpression("\\stackrel-begin", table));
	  	newexp.addChild(exp1);
		newexp.addChild(new SimpleExpression("\\stackrel-middle", table));
		newexp.addChild(exp2);
		newexp.addChild(new SimpleExpression("\\stackrel-end", table));
		return newexp;
	}
}

SimpleExpression modifiedMathDelimiter():
{
    Token mod, del;
    SimpleExpression se;
}
{
    ( mod = <DELIMITERSIZEMODIFIER> del = mathDelimiter())
    {
        String str = mod.image + del.image;
        return new SimpleExpression(str, table);
    }
}

